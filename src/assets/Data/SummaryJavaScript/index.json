{
	"SuperJs": [
		{
			"name": "let var const?",
			"answer": "变量提升；全局声明var声明的会变为window的属性；声明过的报错;const 声明的限制只适用于它指向的变量的引用。换句话说，如果 const 变量引用的是一个对象，那么修改这个对象内部的属性并不违反 const 的限制。"
		},
		{
			"name": "for 循环中的 let 声明",
			"answer": "var：在退出循环时，迭代变量保存的是导致循环退出的值"
		},
		{
			"name": "各种数据类型的转换？",
			"answer": "+的时候转换为number，空字符串=0，非空=1，true=1，false=0；if判断的时候也是"
		},
		{
			"name": "语句",
			"answer": "for of/in,do while while switch ；for in遍历的是数组的索引（即键名），而for of遍历的是数组元素值。"
		},
		{
			"name": "函数",
			"answer": ""
		},
		{
			"name": "原始值与引用值",
			"answer": "引用值得复制：这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个变量实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来"
		},
		{
			"name": "函数传参",
			"answer": "所有函数的参数都是按值传递的；如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。"
		},
		{
			"name": "垃圾回收",
			"answer": "确定哪个变量不会再使用，然后释放它占用的内存。标记清除，引用计数(循环引用无法解决)"
		},
		{
			"name": "array?",
			"answer": ".from转换为数组， of转换为一整个数组；Array.isArray(array)，copywithin，fill"
		},
		{
			"name": "转换方法？",
			"answer": "valueof，tolocalestring，tostring，join()方法接收一个参数，即字符串分隔符，返回包含所有项的字符串"
		},
		{
			"name": "数组的栈队列方法？",
			"answer": "from转换为数组， of转换为一整个数组；Array.isArray(array)，填充方法copywithin，fill,迭代器方法：keys，values,entries；栈方法：push pop，队列方法：shift unshift；排序方法:reverse sort(接收一个比较函数)；操作方法：concat，splice();搜素和位置方法：indexof lastindeof includes；断言函数：find，findindex；迭代方法：every，map，some，foreach，filter；归并方法：reduce，reduceright"
		},
		{
			"name": "定型数组？",
			"answer": "ArrayBuffer，DataView"
		},
		{
			"name": "Map",
			"answer": "key:value形式存储；基本api:set,get,has,size,delete,clear,迭代器，entries"
		},
		{
			"name": "weakmap",
			"answer": "键只能是 Object 或者继承自 Object 的类型,私有变量会存储在弱映射中"
		},
		{
			"name": "Set",
			"answer": "key:value形式存储；基本api:add,has,size,delete,clear,迭代器，entries"
		},
		{
			"name": "weakset",
			"answer": "键只能是 Object 或者继承自 Object 的类型,私有变量会存储在弱映射中"
		},
		{
			"name": "迭代器与生成器",
			"answer": ""
		},
		{
			"name": "对象",
			"answer": "属性分两种：数据属性和访问器属性；定义多个属性 Object defineProperties 读取属性：Object.getOwnPropertyDescriptor；合并对象：assign(浅复制)；计算属性(传入固定的参数名)；简写方法名：解构；工厂模式，构造函数模式(不用返回对象);getPrototypeOf取得一个对象的原型，原型用于在多个对象实例间共享属性和方法的;属性枚举：for-in 循环、Object.keys()、Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()以及 Object.assign()"
		},
		{
			"name": "继承",
			"answer": "：每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数。这样就在实例和原型之间构造了一条原型链。这就是原型链的基本构想。属性通常会在构造函数中定义"
		},
		{
			"name": "代理与反射",
			"answer": "创建空代理，定义捕获器;代理是使用 Proxy 构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象;创建proxy是为了用trap"
		},
		{
			"name": "代理捕获器与反射方法",
			"answer": "get,set,has,defineProerty,getOwnPropertyDescriptor,deleteProperty,ownKeys,getPrototypeOf,setPrototypeOf,isExtensible,preventExtensions,apply,construct,"
		},
		{
			"name": "代理模式",
			"answer": "跟踪属性访问=>隐藏属性=>属性验证=>函数与构造函数参数验证=>数据绑定与可观察对象;跟踪属性访问、隐藏属性、阻止修改或删除属性、函数参数验证、构造函数参数验证、数据绑定，以及可观察对象"
		},
		{
			"name": "箭头函数",
			"answer": "箭头函数不能使用 arguments、super 和new.target，也不能用作构造函数。此外，箭头函数也没有 prototype 属性；函数名：指向函数的指针，"
		},
		{
			"name": "迭代器与生成器",
			"answer": ""
		},
		{
			"name": "迭代器与生成器",
			"answer": ""
		}
	]
}
