{
	"may": [
		{
			"title": "05.07阿里面试",
			"name": "闭包？使用场景？",
			"answer": "访问外部的变量，防抖中，"
		},
		{
			"name": "http请求中的预检请求？",
			"answer": "option"
		},
		{
			"name": "浏览器类多个标签页的通信方式？",
			"answer": "option"
		},
		{
			"name": "es6转es5的原理？",
			"answer": "option"
		},
		{
			"name": "redux的原理？",
			"answer": "option"
		},
		{
			"name": "vue2和vue3的区别？做了那些优化？",
			"answer": "option"
		},
		{
			"name": "深拷贝的方式？",
			"answer": "option"
		},
		{
			"name": "缓存策略？",
			"answer": "option"
		},
		{
			"name": "性能优化？",
			"answer": "针对html，css，js，webpack"
		},
		{
			"name": "浏览器的渲染过程？",
			"answer": "option"
		},
		{
			"title": "05.07平安面试",
			"name": "中间件的优点？",
			"answer": "？？？"
		},
		{
			"name": "less嵌套多少层？",
			"answer": "option"
		},
		{
			"name": "get请求的长度是谁管理？",
			"answer": "option"
		},
		{
			"name": "为什么要抓包？",
			"answer": "option"
		},
		{
			"name": "v-if v-for优先级？",
			"answer": "v-for的优先级高，如果同时出现可在v-for的外层包裹v-if来判断，如果v-if出现在v-for的内部，可以通过计算属性过滤"
		},
		{
			"name": "promise,async,await的区别？",
			"answer": "option"
		},
		{
			"title": "05.10永辉面试",
			"name": "中间件的优点？",
			"answer": "？？？"
		},
		{
			"name": "检测数据类型的方法以及数据类型？",
			"answer": "number string null undefined boolean bigint symbol，typeof instanceof prototype.tostring.call"
		},
		{
			"name": "webpack的流程？以及loader plugin?",
			"answer": "option"
		},
		{
			"name": "ssr pwa ？",
			"answer": "option"
		},
		{
			"name": "nexttick 源码？",
			"answer": "option"
		},
		{
			"name": "scoped原理？",
			"answer": "PostCSS转译实现"
		},
		{
			"name": "清楚浮动？px rem em？",
			"answer": "：after clear:both,父元素：clear both，em相对于父元素，rem相对于根元素"
		},
		{
			"name": "apply bind call区别？",
			"answer": "第一个参数都是this要指向的对象；call和apply都是对函数的直接调用，而bind方法返回的仍然是一个函数；apply中入参是数组形式，call是正常传参"
		},
		{
			"name": "前端抓包和监控？",
			"answer": "option"
		},
		{
			"name": "跨域的处理？",
			"answer": "jsonp？cros？nginx proxy？"
		},
		{
			"name": "vue2和vue3的对比？",
			"answer": "option"
		},
		{
			"name": "常见的安全问题？",
			"answer": "xss：浏览器中执行恶意脚本(无论是跨域还是同域)，从而拿到用户的信息并进行操作，窃取Cookie， 利用 CSP，利用 Cookie 的 HttpOnly 属性 csrf：即跨站请求伪造，指的是黑客诱导用户点击链接，打开黑客的网站，然后黑客利用用户目前的登录状态发起跨站请求"
		},
		{
			"title": "05.11面试",
			"name": "apply call bind的区别？实际操作的时候第一个参数指向window",
			"answer": "？？？"
		},
		{
			"name": "浏览器的缓存",
			"answer": "第二次访问的时候才缓存，"
		},
		{
			"name": "vue中对象的删除增加可以实现响应式？",
			"answer": "option"
		},
		{
			"name": "深拷贝的的方法？",
			"answer": "json.parse=对function会丢失；递归"
		},
		{
			"name": "keep-alive的配置？max删除机制？",
			"answer": ""
		},
		{
			"name": "computed 和methods？",
			"answer": "计算属性是基于它们的响应式依赖进行缓存的。"
		},
		{
			"name": "如何实现等高正方形？",
			"answer": "vm"
		},
		{
			"name": "rem em区别？",
			"answer": "option"
		},
		{
			"name": "内存泄漏？",
			"answer": "指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。"
		},
		{
			"name": "watch实现原理？",
			"answer": ""
		},
		{
			"name": " omputed实现原理？",
			"answer": ""
		},
		{
			"name": "keep-alive的原理？",
			"answer": ""
		},
		{
			"name": "require import?",
			"answer": "require 是赋值过程并且是运行时才执行， import 是解构过程并且是编译时执行。require可以理解为一个全局方法require是在运行时才引入模块并且还赋值给某个变量，而import只需要依据import中的接口在编译时引入指定模块"
		},
		{
			"name": "如何给对象设置私有属性？",
			"answer": ""
		},
		{
			"name": "事件循环？",
			"answer": ""
		},
		{
			"name": "cokie session",
			"answer": "session保存在服务器，客户端不知道其中的信息；cookie保存在客户端，服务器能够知道其中的信息 ;session中保存的是对象，cookie中保存的是字符串 "
		},
		{
			"name": "flex布局？属性？",
			"answer": ""
		},
		{
			"name": "js事件委托？怎么阻止事件冒泡？阻止事件捕获？",
			"answer": ""
		},
		{
			"name": "https原理？怎么加密的？",
			"answer": ""
		},
		{
			"name": "路由懒加载的原理？",
			"answer": ""
		},
		{
			"name": ".vue文件怎么变成.js文件？",
			"answer": ""
		},
		{
			"name": "vue的模板编译原理？AST？",
			"answer": ""
		},
		{
			"name": "浏览器执行打包完的js文件的顺序？",
			"answer": ""
		},
		{
			"name": "如何画一个三角形？",
			"answer": "width:0;border-left/right:200px  solid transparent;bottom 200px red solid"
		},
		{
			"name": "for in of 的区别？",
			"answer": "遍历对象：in 遍历key，of不行需要迭代器支持；遍历数组：in 遍历key， of遍历value"
		},
		{
			"name": "foreach map的区别？",
			"answer": "map返回一个新数组，需要return；foreach中return无效"
		},
		{
			"name": "cdn?",
			"answer": "content delivery network 是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络。"
		},
		{
			"name": "浏览器渲染过程是阻塞还是非阻塞？",
			"answer": ""
		},
            {
			"name": "浏览器缓存的一些字段？",
			"answer": "强缓存：Expires，Cache-control；协商缓存：Last-Modified(服务器上文件的最后修改时间);Etag(依据hash算法得来)"
		},
            {
			"name": "防抖节流？",
			"answer": "防抖：单位时间内触发后重新计时（提交，搜索框）；节流：单位时间内只触发一次（拖拽，缩放）"
		},
            {
			"name": "浏览器渲染过程是阻塞还是非阻塞？",
			"answer": ""
		}
	]
}
