
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div style="background-color: azure;">
    <p>水平居中</p>
    <div class="div01" >
     <p class="p01">我是水平居中</p> 
    </div>
    <hr>
    <p>垂直居中</p>
    <div class="div02">

    </div>
    <hr>
    <p>水平垂直居中</p>
  
      <div class="div03">
        <div class="div003">

        </div>
      </div>
  
    
  </div>
  <button onclick="test()">click</button>
    <button onclick="testFun()">testFun</button>
    <button onclick="console.log(newPerson._name)">person</button>

  <script>
        function testFun(name) {

            console.log('log1')

            Promise.resolve().then(()=>{console.log('then1')})
       
            setTimeout(() => {
                  console.log('settimeout');
            }, 0);

            Promise.resolve().then(()=>{

            Promise.resolve().then(()=>{
                  setTimeout(() => {
                  console.log('settimeout in in');
            }, 0);
            console.log('then1 in')})
       
            setTimeout(() => {
                  console.log('settimeout in');
            }, 0);
            console.log('then2')
            
            })
            console.log('log2');
            /* 
                  不是一个一个执行是一轮一轮执行
                  宏任务主代码块=>微任务=>宏=>微任务
            */
          

        }
            function Person(name) {
                   /* 
                  属性私有
           */
            let _name=name
            this.getName=()=>{
                  return _name
            }
            }
            let newPerson=new Person('jack')
      function A(name,age){
            //工厂模式
            let factoryA=new Object()
            factoryA.age=age
            factoryA.name=name
            factoryA.say=function(){
                  console.log(this.name+this.age);
            }
            // factoryA.say=()=>{
            //       console.log(this.age+this.name) //ARROW FUNCTION
                  
            //       console.log(this);
            // }
            return factoryA
      }

      let B= A('JACK',25)
      console.log(B);
      B.say()
      /* 
            继承
            prototype
            以下
            把东西放在原型上
      */
      function Person(name,age) {
            Person.prototype.sex='boy'
            Person.prototype.name=name
            Person.prototype.age=age
            Person.prototype.say=function() {
                  console.log(this.name,'111')
            }
      }
      let person=new Person()
    //   console.log(Person.prototype.__proto__)
      person.name='jack luo'
      person.sex='girl'
      console.log(person)
      let person1=new Person()
      console.log(person1.sex,'person1')
      delete person.name//删除属性
      console.log(person.name,'after delete')
      person.name='jack1'
      console.log(person.hasOwnProperty('name'),'hasOwnProperty')//检测是否是自己的属性
      console.log(Object.keys(Person.prototype))
      /* 
            对象迭代
      */
      const obj={
            o:'jack',
            j:'ada',
            l:{}
      }
      console.log(Object.values(obj))
      const objCopy=Object.values(obj)
      console.log(objCopy);
      /* 
        继承
        构造函数
      */
     function SuperType() {
         this.colors=['red','blue','green','yellow']
     }
     function SubType() {
         //继承SuperType
         SuperType.call(this)
         console.log(this,'call')
     }
     let instance1=new SubType()
     instance1.colors.push('black')
     console.log(instance1.colors)

     let instance2=new SubType()
     console.log(instance2.colors)

     /* 
        继承
        组合继承
        构造函数+prototype
     */
    function SuperTypeOne(name) {
        this.name=name
        this.colors=['red','blue','green','yellow']
    }
    SuperTypeOne.prototype.sayName=function(){
        console.log(this.name,'放在prototype的方法拿到名字')
    }
    //继承属性
    function SubTypeOne(name,age) {
        SuperTypeOne.call(this,name)
        this.age=age
    }
    //继承方法
    SubTypeOne.prototype=new SuperTypeOne()
    SubTypeOne.prototype.sayAge=function(){
        console.log(this.age)
    }
    let instance3=new SubTypeOne('jackluo',25)
    instance3.colors.push('sky')

    let instance4=new SubTypeOne('jackluo4',26)
    instance4.colors.push('sky4')
    console.log(instance3,'----',instance4)
    /* 
        寄生式继承
    */
   function createAnother(original) {
       let clone=Object(original)
       clone.sayHi=function(){
           console.log('hi')
       }
       return clone
   }
   let personCreate={
       name:'jackluotong',
       friends:['jerry','william','some','any']
   }
   let anotherPerson=createAnother(personCreate)
   console.log('anotherPerson',anotherPerson)
   anotherPerson.sayHi()
   /* 
        寄生式组合
   */
  function SuperTypeTwo(name) {
      this.name=name
      this.colors=['r','g','n','b']
  }
  SuperTypeTwo.prototype.sayName=function(){
      console.log(this.name)
  }
  function SubTypeTwo(name,age) {
      SuperTypeTwo.call(this,name)
      this.age=age
  }
  SubTypeTwo.prototype=new SuperTypeTwo()
  SubTypeTwo.prototype.constructor=SubTypeTwo
  SubTypeTwo.prototype.sayAge=function(){
      console.log(this.age)
  }


  function inheritPrototype(subType,superType) {
        let prototype=Object(subType,superType)
        prototype.constructor=subType
        subType.prototype=prototype    
  }
  /* 
        inheritPrototype()函数实现了寄生式组合继承的核心逻辑。这个函数接收两个参数：子
        类构造函数和父类构造函数。在这个函数内部，第一步是创建父类原型的一个副本。然后，给返回的
        prototype 对象设置 constructor 属性，解决由于重写原型导致默认 constructor 丢失的问题。最
        后将新创建的对象赋值给子类型的原型。如下例所示，调用 inheritPrototype()就可以实现前面例
        子中的子类型原型赋值
  */
  function SuperType(name) { 
 this.name = name; 
 this.colors = ["red", "blue", "green"]; 
} 
SuperType.prototype.sayName = function() { 
 console.log(this.name); 
}; 
function SubType(name, age) { 
 SuperType.call(this, name); 

 this.age = age; 
} 
inheritPrototype(SubType, SuperType); 
SubType.prototype.sayAge = function() { 
 console.log(this.age); 
}


function newFun(obj,...rest){
    console.log('thisthisthisthisthis',this)
    const newObj=Object.create(obj.prototype)
    const result=obj.apply(newObj,rest)
    return typeof result==='object'?result:newObj
}
let testNew=newFun(SuperType,'jack')
console.log(testNew,'=========')
/* 
        class
*/

    class TestClass{
        constructor(override){
            this.foo='foo'
            if(override){
                return{
                    bar:'bar'
                }
            }
            console.log('TestDemo',this)
        }
    }
    let Test1=new TestClass()
    ,Test2=new TestClass('hehe')
    console.log(Test1,'TESTETSETSET',Test2,Object.prototype.toString.call(TestClass) ,TestClass.prototype,Test1 instanceof TestClass)//，可以使用 instanceof 操作符检查构造函数原型是否存在于实例的原型链中
    let pp=new class Foo{
        constructor(id){
            console.log(id)
        }
    }(79)
    console.log(pp)
    /* 
        获取和设置访问器
    */
   class TestTwo{
       set name(newName){
            this.name_=newName
       }
       get name(){
           return this.name_
       }
   }
//    let p1=new TestTwo()
//    p1.name='jack'
//    console.log(p1.name)
class TestThree{
    constructor(){
        //存在于不同的实例上
        this.locate=()=>{
            console.log('in instance',this)
        }
    }
    //定义在类的原型对象上
    locate(){
        console.log('prototype',this)
    }
    //定义在类本身
    static locate(){
        console.log('class',this)
    }
}
let p2=new TestThree()
p2.locate()
TestThree.prototype.locate()
TestThree.locate()

class Person01{
    sayName(){
        return `${Person01.greeting}${this.name}`
    }
}
Person01.greeting='my name is:'
Person01.prototype.name='jack'
let p01=new Person01()
console.log(p01.sayName())

function TestFunA(name,age){
    this.name=name
    this.age=age
    return name+age
}
TestFunA.sex='boy'
TestFunA.prototype.sex='girl'
let newA=TestFunA('jack',27)
console.log(newA,TestFunA.prototype)

/* 
    迭代器和生成器
    因为支持生成器方法，所以可以通过添加一个默认的迭代器，把类实例变成可迭代对象
*/
class IteratorType{
    //在原型上定义
    *createNickIterator(){
        yield'jack1';
        yield'jack2';
        yield'jack3';
        yield'jack4';
    }
    //在类上定义
    static *createJobIterator(){
        yield 'er';
        yield 'er2';
        yield 'er3';
        yield 'er4';
    }
}
let jobIter=IteratorType.createJobIterator()
console.log(jobIter.next().value,jobIter.next().value)

class PersonIter{
    constructor(){
        this.nickNames=['jack','jerry','william','jennifer']
    }
    *[Symbol.iterator](){
        yield *this.nickNames.entries()
    }
}
let pi=new PersonIter()
for(let [idx,nickname]of pi){
    console.log(idx,nickname)
}
/* 
entries() 方法返回一个数组的迭代对象，该对象包含数组的键值对 (key/value)。

迭代对象中数组的索引值作为 key， 数组元素作为 value。
*/

/* 
      proxy
 */

 const target={
       foo:'bar'
 }
 const firstProxy=new Proxy(target,{
       get(){
             console.log('first proxy')
             return Reflect.get(...arguments)
       }
 })
 
const secondProxy=new Proxy(firstProxy,{
       get(trapTarget,property,receiver){//create a trap
             console.log('second proxy')
             return Reflect.get(...arguments)
       },
       set(newVal){
            console.log(newVal)
       }
 })
 console.log(secondProxy.foo)
 
 /* 
      function part
      arrow function
 */
const a1=(x)=>{return x*3}
console.log(a1(33),'arrow function')
function a11(){
    return arguments[0]*3 
}
// a11(3)
console.log(a11(3))
const random=()=>{return Math.floor(Math.random()*10)}
console.log(random())
/* 
      函数参数
*/
function howManyFun() {
      console.log(arguments.length)
}

howManyFun('1','222','11',0)
</script>



<script>
  function test(){
    console.log('script start');

setTimeout(function() {
  console.log('setTimeout');
}, 0);

Promise.resolve().then(function() {
  console.log('promise1');
}).then(function() {
  console.log('promise2');
});

console.log('script end');
 
    setTimeout(()=>{
        new Promise(resolve =>{
            resolve();
        }).then(()=>{
            console.log('test');
        });

        console.log(4);
    });

    new Promise(resolve => {
        resolve();
        console.log(1)
    }).then( () => {
        console.log(3);
        Promise.resolve().then(() => {
            console.log('before timeout');
        }).then(() => {
            Promise.resolve().then(() => {
                console.log('also before timeout')
            })
        })
    })
    console.log(2);
  }
  function f(x){
    if(x>0)
    return x+f(x-1)
    else
    return 0
  }
 
  console.log( f(100))
  /**
   * 函数自己调用自己
   * 只递不归会导致程序奔溃
   * 要在适当的时候终止递归
  */
    //1 3 4
</script>
<style>
  .div01{
    background-color: blue;
    width: 100px;
    height: 100px;
    margin: 0 auto;
    display: flex;
    justify-content: center;
    align-items: center;
  }
/* .p01{
 
} */
.div02{
  background-color: rgb(236, 8, 8);
  width: 100px;
  height: 100px;
  display: inline-block;
  vertical-align:middle;
}
.div03{
  background-color: rgb(8, 236, 38);
  width: 100px;
  height: 100px;
  /* display: flex;
  justify-content: center;
  align-self: center;  针对父元素的写法*/
  /* display: table; */
  /* display: table-cell;
  vertical-align: middle;
  text-align: center; */
  display: flex;
  justify-content: center; /* 使子项目水平居中*/
  align-items: center; /*使子项目垂直居中*/
}
.div003{
  background-color: rgb(248, 20, 248);
  width: 20%;
  height: 20%;
  /* display: inline-block; */
}
</style>
</body>
</html>